# Server-Side Event Card Layout Engine

This directory contains the **server-driven layout system for event cards** used to build the
Event feed UI.

Instead of trying to format, and designate the raw events into slots on the client, 
the server compiles a **slotted layout plan** describing exactly what ought to appear 
in the UI.

The client executes this layout plan via the 
**renderLayout** pipeline(found in **@/src/components/pipelines/events directory**).

This allows:
- deterministic layouts
- easy pagination
- strict schema validation of UI output

---

## Architecture Overview

Each step is executed by its own utility function.

Each utility function used can be found in the **@/src/server/layout/utils** directory.

### Event Formatting (via formatRawEvents)

`formatRawEvents.ts` converts raw database rows into `EventSchemaType`:

This prevents db-specific types (Column type, Date etc) from leaking to the client side.

### Layout slots

The layout engine outputs an array of **LayoutSlots**, where each slot is either:

- a `card` (single event with size + variant), or
- a `stack` (a pair of events rendered vertically)

The schema is defined in **@src/schemas/layoutSlotSchema.ts**

This makes layout a **typed protocol** between server and client.

These files define how the feed should be structured:

- `designateLayoutSlot.ts`  
  Decides what kind of slot should appear at a given index (hero, thumbnail, stack, etc).

- `getCardSizing.ts`  
  Maps `card` variants to responsive grid sizes.

These functions are pure and deterministic; they describe **layout rules**, not UI.


---

### Layout Compiler

`compileEventsLayout.ts` is the main entry point.

It runs the full server-side pipeline:

input: rows(type `Events` from `@/src/server/db/types/db.d.ts` generated by kysely-codegen)

- formatRawEevnts
- buildLayoutSlots
- layoutSlotValidator

output: layout(type `LayoutSlotSchemaType[]`)

This ensures that only schema validated layout instructions reach the client

## Why this exists

The purpose of this rendering engine is to decouple what ought to be 
rendered(now determined here on the server) from how to render it(client responsibility)

#### The results are:
- simpler react components & UI pipelines
- easy pagination
- consistent layouts